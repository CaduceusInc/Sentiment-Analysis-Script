[
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "combinations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "csr_matrix",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "KFold",
        "importPath": "sklearn.cross_validation",
        "description": "sklearn.cross_validation",
        "isExtraImport": true,
        "detail": "sklearn.cross_validation",
        "documentation": {}
    },
    {
        "label": "LogisticRegression",
        "importPath": "sklearn.linear_model",
        "description": "sklearn.linear_model",
        "isExtraImport": true,
        "detail": "sklearn.linear_model",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "tarfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tarfile",
        "description": "tarfile",
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "urllib.request",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.request",
        "description": "urllib.request",
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "download_data",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def download_data():\n    \"\"\" Download and unzip data.\n    DONE \n    \"\"\"\n    url = 'https://www.dropbox.com/s/xk4glpk61q3qrg2/imdb.tgz?dl=1'\n    urllib.request.urlretrieve(url, 'imdb.tgz')\n    tar = tarfile.open(\"imdb.tgz\")\n    tar.extractall()\n    tar.close()\ndef read_data(path):",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "read_data",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def read_data(path):\n    \"\"\"\n    Walks all subdirectories of this path and reads all\n    the text files and labels.\n    Params:\n      path....path to files\n    Returns:\n      docs.....list of strings, one per document\n      labels...list of ints, 1=positive, 0=negative label.\n               Inferred from file path (i.e., if it contains",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "tokenize",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def tokenize(doc, keep_internal_punct=False):\n    \"\"\"\n    Tokenize a string.\n    The string should be converted to lowercase.\n    If keep_internal_punct is False, then return only the alphanumerics (letters, numbers and underscore).\n    If keep_internal_punct is True, then also retain punctuation that\n    is inside of a word. E.g., in the example below, the token \"isn't\"\n    is maintained when keep_internal_punct=True; otherwise, it is\n    split into \"isn\" and \"t\" tokens.\n    Params:",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "token_features",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def token_features(tokens, feats):\n    \"\"\"\n    Add features for each token. The feature name\n    is pre-pended with the string \"token=\".\n    Note that the feats dict is modified in place,\n    so there is no return value.\n    Params:\n      tokens...array of token strings from a document.\n      feats....dict from feature name to frequency\n    Returns:",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "token_pair_features",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def token_pair_features(tokens, feats, k=3):\n    \"\"\"\n    Compute features indicating that two words occur near\n    each other within a window of size k.\n    For example [a, b, c, d] with k=3 will consider the\n    windows: [a,b,c], [b,c,d]. In the first window,\n    a_b, a_c, and b_c appear; in the second window,\n    b_c, c_d, and b_d appear. This example is in the\n    doctest below.\n    Note that the order of the tokens in the feature name",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "lexicon_features",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def lexicon_features(tokens, feats):\n    \"\"\"\n    Add features indicating how many time a token appears that matches either\n    the neg_words or pos_words (defined above). The matching should ignore\n    case.\n    Params:\n      tokens...array of token strings from a document.\n      feats....dict from feature name to frequency\n    Returns:\n      nothing; feats is modified in place.",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "featurize",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def featurize(tokens, feature_fns):\n    \"\"\"\n    Compute all features for a list of tokens from\n    a single document.\n    Params:\n      tokens........array of token strings from a document.\n      feature_fns...a list of functions, one per feature\n    Returns:\n      list of (feature, value) tuples, SORTED alphabetically\n      by the feature name.",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "vectorize",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def vectorize(tokens_list, feature_fns, min_freq, vocab=None):\n    \"\"\"\n    Given the tokens for a set of documents, create a sparse\n    feature matrix, where each row represents a document, and\n    each column represents a feature.\n    Params:\n      tokens_list...a list of lists; each sublist is an\n                    array of token strings from a document.\n      feature_fns...a list of functions, one per feature\n      min_freq......Remove features that do not appear in",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def accuracy_score(truth, predicted):\n    \"\"\" Compute accuracy of predictions.\n    DONE\n    Params:\n      truth.......array of true labels (0 or 1)\n      predicted...array of predicted labels (0 or 1)\n    \"\"\"\n    return len(np.where(truth==predicted)[0]) / len(truth)\ndef cross_validation_accuracy(clf, X, labels, k):\n    \"\"\"",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "cross_validation_accuracy",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def cross_validation_accuracy(clf, X, labels, k):\n    \"\"\"\n    Compute the average testing accuracy over k folds of cross-validation. You\n    can use sklearn's KFold class here (no random seed, and no shuffling\n    needed).\n    Params:\n      clf......A LogisticRegression classifier.\n      X........A csr_matrix of features.\n      labels...The true labels for each instance in X\n      k........The number of cross-validation folds.",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "eval_all_combinations",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def eval_all_combinations(docs, labels, punct_vals,\n                          feature_fns, min_freqs):\n    \"\"\"\n    Enumerate all possible classifier settings and compute the\n    cross validation accuracy for each setting. We will use this\n    to determine which setting has the best accuracy.\n    For each setting, construct a LogisticRegression classifier\n    and compute its cross-validation accuracy for that setting.\n    In addition to looping over possible assignments to\n    keep_internal_punct and min_freqs, we will enumerate all",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "plot_sorted_accuracies",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def plot_sorted_accuracies(results):\n    \"\"\"\n    Plot all accuracies from the result of eval_all_combinations\n    in ascending order of accuracy.\n    Save to \"accuracies.png\".\n    \"\"\"\n    accuracies_list=[]\n    for accuracy in results:\n        accuracies_list.append(accuracy['accuracy'])\n    x = range(0,len(accuracies_list))",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "mean_accuracy_per_setting",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def mean_accuracy_per_setting(results):\n    \"\"\"\n    To determine how important each model setting is to overall accuracy,\n    we'll compute the mean accuracy of all combinations with a particular\n    setting. For example, compute the mean accuracy of all runs with\n    min_freq=2.\n    Params:\n      results...The output of eval_all_combinations\n    Returns:\n      A list of (accuracy, setting) tuples, SORTED in",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "fit_best_classifier",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def fit_best_classifier(docs, labels, best_result):\n    \"\"\"\n    Using the best setting from eval_all_combinations,\n    re-vectorize all the training data and fit a\n    LogisticRegression classifier to all training data.\n    (i.e., no cross-validation done here)\n    Params:\n      docs..........List of training document strings.\n      labels........The true labels for each training document (0 or 1)\n      best_result...Element of eval_all_combinations",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "top_coefs",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def top_coefs(clf, label, n, vocab):\n    \"\"\"\n    Find the n features with the highest coefficients in\n    this classifier for this label.\n    See the .coef_ attribute of LogisticRegression.\n    Params:\n      clf.....LogisticRegression classifier\n      label...1 or 0; if 1, return the top coefficients\n              for the positive class; else for negative.\n      n.......The number of coefficients to return.",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "parse_test_data",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def parse_test_data(best_result, vocab):\n    \"\"\"\n    Using the vocabulary fit to the training data, read\n    and vectorize the testing data. Note that vocab should\n    be passed to the vectorize function to ensure the feature\n    mapping is consistent from training to testing.\n    Note: use read_data function defined above to read the\n    test data.\n    Params:\n      best_result...Element of eval_all_combinations",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "print_top_misclassified",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def print_top_misclassified(test_docs, test_labels, X_test, clf, n):\n    \"\"\"\n    Print the n testing documents that are misclassified by the\n    largest margin. By using the .predict_proba function of\n    LogisticRegression <https://goo.gl/4WXbYA>, we can get the\n    predicted probabilities of each class for each instance.\n    We will first identify all incorrectly classified documents,\n    then sort them in descending order of the predicted probability\n    for the incorrect class.\n    E.g., if document i is misclassified as positive, we will",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "def main():\n    \"\"\"\n    Put it all together.\n    DONE.\n    \"\"\"\n    feature_fns = [token_features, token_pair_features, lexicon_features]\n    # Download and read data.\n    download_data()\n    docs, labels = read_data(os.path.join('data', 'train'))\n    # Evaluate accuracy of many combinations",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "neg_words",
        "kind": 5,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "neg_words = set(['bad', 'hate', 'horrible', 'worst', 'boring'])\npos_words = set(['awesome', 'amazing', 'best', 'good', 'great', 'love', 'wonderful'])\ndef lexicon_features(tokens, feats):\n    \"\"\"\n    Add features indicating how many time a token appears that matches either\n    the neg_words or pos_words (defined above). The matching should ignore\n    case.\n    Params:\n      tokens...array of token strings from a document.\n      feats....dict from feature name to frequency",
        "detail": "sentimentScript",
        "documentation": {}
    },
    {
        "label": "pos_words",
        "kind": 5,
        "importPath": "sentimentScript",
        "description": "sentimentScript",
        "peekOfCode": "pos_words = set(['awesome', 'amazing', 'best', 'good', 'great', 'love', 'wonderful'])\ndef lexicon_features(tokens, feats):\n    \"\"\"\n    Add features indicating how many time a token appears that matches either\n    the neg_words or pos_words (defined above). The matching should ignore\n    case.\n    Params:\n      tokens...array of token strings from a document.\n      feats....dict from feature name to frequency\n    Returns:",
        "detail": "sentimentScript",
        "documentation": {}
    }
]